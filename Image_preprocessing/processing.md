对color_detection函数，传进去分割好的raw_image，进行二值化，进行字符分割。
detect_color依据颜色不同，设置不同亮度阈值，进行二值化。

颜色，亮度阈值： 白色：180，  黄色：130  浅蓝：100   红色：65
依据宽高比判定黏连


出错： 要是是检测错颜色，要么是阈值没用上  后者可能性更大

行高12， 字符宽度从3到6不等

判断黏连状态：高宽比小于1.8，即判定为黏连字符，目前只考虑两字符黏连情况。
添加三字符黏连情况，单字符宽度3~6不等，行高12，宽高比就是2~4不等，
首先，高宽比<1.8说明出现黏连，
需要说明的是虽然单字符情况可能出现3~6，但是考虑到字符间距，出现黏连时候需要考虑间距，则此时，黏连字符大概字符长度在4~6之间，双字符长度在8~12之间；三字符黏连在12~18之间；
故而判定三字符黏连的高宽比为设到小于0.9，为三字符；
在0.9~1.8之间为两字符黏连。


列判定：
输入：二值化后的图
输出：单个字符

# 问题：不能将红色与灰色列区分出来
解放思路：将切割后的原图输入进来，再次做一遍颜色过滤，再二值化，最后完成字符切割。

原因：传进来的是原图，但是还是按照行二值化方法完成的图像二值化，此时，灰色点也被二值化为白色像素点，造成最后的结果检测到灰色。
解决思路：传进来原图，设计列二值化方法，完成行图像的二值化，讲灰色区域二值化为背景颜色。

注：终究还是二值化gen_gray function上出了问题，解决思路是先用红色进行过滤一下原图，再进行二值化（前面用红色过滤只是为了检测待检测行的颜色，只做判定，并未做操作）

注：只需对红色、淡蓝进行特殊处理，因为这两种颜色进行二值化，选定的亮度阈值分别为65,100。这个亮度阈值不能将灰色过滤，对于绿色与白色，亮度阈值足以过滤到灰色。


说明：
1. 中间含灰色widget： 
	img_char：			width：212		height：12				column_white_num_max：9		column_black_num_max：12
	img_row:			width: 212		image_height：345		row_white_num_max：81		row_black_num_max：212
	列起始判定条件：column_white_num[column_mark] > column_white_num_max：9 * 0.05 = 0.4 即出现白色像素点即可
	列终止判定条件：column_black_num[m] > column_black_num_max ：12 * 0.95 = 11.4 即全为背景像素点
	
	行起始判定条件：row_white_num[row_mark] > row_white_num_max * 0.1 = 8.1 
	行终止判定条件：row_black_num[m] > row_black_num_max * 0.9 = 190.8
	
2. 虽然淡蓝与灰色也不易通过亮度区分，但是因为不存在淡蓝与灰色共存状态，故而暂不进行处理。	

3. 亮度阈值： 白色：180，  黄色：130  浅蓝：100   红色：65


待解决：
1. 小数点不能检测     开始位置都没找到，存在这个情况。（已解决）
2. 出现数字1不能检测（原因是字符列切割时候限制必须在2列以上，以确保过滤直线，反倒成了问题）（已解决）
3. 可能会出现黄色与白色（目前没有看到红色与其他颜色共同出现的情况，暂不考虑）
4. 会将灰色区域检测出来（已解决）
5. 带框数字检测
6. 断裂字符被当做两字符处理了：因为目前处理粒度比较小，单像素级别，造成如果二值化后的图像出现中间断裂会当做双字符进行处理。


解决思路：
2. 对于数字1，列分割时候，检测当列出现像素点高于一定阈值后，如果其实列到结束列的列宽不满足>2，但是如果列中像素大于某设定阈值则视为数字1看待。
3. 对于daunt这种情况下可通过尽大可能地让图像灰度更饱满一些，虽然会造成列区分度降低，但目前这应该是比较好的方案

已解决：
1. 字符黏连问题，目前扩展到3字符黏连判定。
2. 红色、灰色区分问题，通过转换到LAB空间，再转换到HSV空间，依据亮度进行区分。
3. 已解决检测到灰色区域，通过将detect_row_img_color中不符合判定颜色，则一律依照黄色亮度阈值进行划分（之前设定是红色阈值65，现在设置为黄色阈值130）
4. 小数点问题，通过设定单个像素点及两个像素点检测规则
    elif column_white_num[column_mark] / column_white_num_max < 0.34:
	elif column_white_num[column_mark] / column_white_num_max and column_white_num[column_mark+1] / column_white_num_max < 0.34:
	阈值设到0.34保证能承受大约3个像素点；
5. 灰色区域检测出来，行检测出来无所谓，当成背景图像直接处理一遍，得不到字符识别结果输出即可
6. 带框解决方案，先去框，利用规则，横框线利用两行间距大于5限定直接去掉，列框线利用列长像素比行高像素长度相差在1之内的一律视为列线。
   基于此，讲白色亮度设定为160（便于完整显示框线）
   
   
   
   

   
   

21 
   
	
